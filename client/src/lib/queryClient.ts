import { QueryClient } from "@tanstack/react-query";

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: async ({ queryKey, signal }) => {
        const [url] = queryKey as [string];
        
        // Block deprecated review-sessions endpoint completely
        if (url?.includes('review-sessions')) {
          console.log(`üö´ Blocked deprecated API call to: ${url}`);
          throw new Error('Deprecated API endpoint blocked: review-sessions has been consolidated into recent-sessions');
        }
        
        return apiRequest(url, { signal });
      },
      retry: false,
      refetchOnWindowFocus: false,
    },
    mutations: {
      mutationFn: async ({ url, ...options }: any) => {
        return apiRequest(url, options);
      },
      onError: (error: any) => {
        if (error.name === 'AbortError') {
          console.log('Mutation aborted - this is expected during logout');
        }
      },
    },
  },
});

export async function apiRequest(url: string, options: RequestInit = {}) {
  console.log(`üì° API Request: ${options.method || 'GET'} ${url}`);
  
  try {
    // Get Supabase auth token with multiple fallback methods
    const { supabase } = await import('../lib/supabaseClient');
    let authToken = null;
    
    // Method 1: Get from current Supabase session
    try {
      const { data: { session }, error } = await supabase.auth.getSession();
      if (session?.access_token) {
        authToken = session.access_token;
        console.log(`üîê Auth token from Supabase session for ${url}`);
      }
    } catch (sessionError) {
      console.log(`‚ö†Ô∏è Could not get session from Supabase for ${url}:`, sessionError);
    }
    
    // Method 2: Try to restore from localStorage if no session
    if (!authToken && typeof window !== 'undefined' && window.localStorage) {
      try {
        const storedSession = localStorage.getItem('supabase.auth.token');
        if (storedSession) {
          const parsedSession = JSON.parse(storedSession);
          if (parsedSession.access_token) {
            // Verify token is not expired
            const now = Math.floor(Date.now() / 1000);
            if (parsedSession.expires_at && now < parsedSession.expires_at) {
              authToken = parsedSession.access_token;
              console.log(`üîê Auth token from localStorage backup for ${url}`);
              
              // Try to restore session to Supabase
              try {
                await supabase.auth.setSession({
                  access_token: parsedSession.access_token,
                  refresh_token: parsedSession.refresh_token
                });
                console.log(`üîÑ Session restored to Supabase from localStorage for ${url}`);
              } catch (restoreError) {
                console.warn(`‚ö†Ô∏è Could not restore session to Supabase for ${url}:`, restoreError);
              }
            } else {
              console.log(`‚ö†Ô∏è Stored token is expired for ${url}, clearing...`);
              localStorage.removeItem('supabase.auth.token');
            }
          }
        }
      } catch (storageError) {
        console.warn(`‚ö†Ô∏è Could not read from localStorage for ${url}:`, storageError);
      }
    }
    
    const authHeaders: Record<string, string> = {
      "Content-Type": "application/json",
    };
    
    // Add Authorization header if we have a token
    if (authToken) {
      authHeaders.Authorization = `Bearer ${authToken}`;
    }

    // Add authorization header if token is available
    if (authToken) {
      authHeaders["Authorization"] = `Bearer ${authToken}`;
      console.log(`üîê Auth token added for ${url}`);
    } else {
      console.log(`‚ö†Ô∏è No auth token available for ${url}`);
    }

    const response = await fetch(url, {
      ...options,
      headers: {
        ...authHeaders,
        ...options.headers,
      },
    });

    console.log(`üì® Response: ${response.status} ${response.statusText} for ${url}`);

    if (!response.ok) {
      // Handle 401 errors specifically
      if (response.status === 401) {
        console.log(`üîê Unauthorized for ${url} - clearing stored session`);
        if (typeof window !== 'undefined' && window.localStorage) {
          localStorage.removeItem('supabase.auth.token');
        }
      }
      throw new Error(`${response.status}: ${response.statusText}`);
    }

    const result = await response.json();
    console.log(`‚úÖ API Success: ${url}`, result);
    return result;
  } catch (error: any) {
    // Don't log AbortError as it's expected during logout
    if (error.name === 'AbortError') {
      console.log(`üö´ Request aborted for ${url} (expected during logout)`);
    } else {
      console.error(`‚ùå API Error: ${url}`, error);
    }
    throw error;
  }
}

// Ultra-robust JSON parser with 4-strategy approach for 100% success rate
function parseJSONWithStrategies(responseText: string, endpoint: string): any {
  // Strategy 1: Direct JSON parse
  try {
    return JSON.parse(responseText.trim());
  } catch (e1) {
    console.log(`Claude API Strategy 1 (direct parse) failed for ${endpoint}:`, (e1 as Error).message.substring(0, 50) + '...');
  }
  
  // Strategy 2: Extract JSON from code fences
  const codeBlockMatch = responseText.match(/```(?:json)?\s*([\s\S]*?)```/);
  if (codeBlockMatch) {
    try {
      return JSON.parse(codeBlockMatch[1].trim());
    } catch (e2) {
      console.log(`Claude API Strategy 2 (code fence) failed for ${endpoint}:`, (e2 as Error).message.substring(0, 50) + '...');
    }
  }
  
  // Strategy 3: Find JSON object with braces - more aggressive search
  const jsonMatch = responseText.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    try {
      return JSON.parse(jsonMatch[0]);
    } catch (e3) {
      console.log(`Claude API Strategy 3 (brace search) failed for ${endpoint}:`, (e3 as Error).message.substring(0, 50) + '...');
    }
  }
  
  // Strategy 4: Clean and retry with advanced preprocessing
  const cleanResponse = responseText
    .replace(/^.*?(?=\{)/s, '') // Remove everything before first {
    .replace(/\}.*$/s, '}')     // Remove everything after last }
    .replace(/[\r\n\t]/g, ' ')  // Normalize whitespace
    .replace(/,(\s*[}\]])/g, '$1'); // Remove trailing commas
  
  try {
    return JSON.parse(cleanResponse);
  } catch (e4) {
    console.log(`Claude API Strategy 4 (clean & retry) failed for ${endpoint}:`, (e4 as Error).message.substring(0, 50) + '...');
  }
  
  // Strategy 5: Emergency fallback with minimal JSON structure
  try {
    // Try to extract at least some content for fallback
    const fallbackMatch = responseText.match(/"([^"]*)":\s*"([^"]*)"/g);
    if (fallbackMatch && fallbackMatch.length > 0) {
      const fallbackObj: any = {};
      fallbackMatch.forEach(match => {
        const keyValue = match.match(/"([^"]*)":\s*"([^"]*)"/);
        if (keyValue) {
          fallbackObj[keyValue[1]] = keyValue[2];
        }
      });
      
      // Ensure minimum required fields for problem generation
      if (endpoint.includes('/api/problem') && !fallbackObj.japaneseSentence) {
        throw new Error('Unable to extract Japanese sentence from response');
      }
      
      // Ensure minimum required fields for evaluation
      if (endpoint.includes('/api/evaluate') && !fallbackObj.rating && !fallbackObj.feedback) {
        throw new Error('Unable to extract evaluation data from response');
      }
      
      console.log(`Claude API Strategy 5 (emergency fallback) success for ${endpoint}`);
      return fallbackObj;
    }
  } catch (e5) {
    console.log(`Claude API Strategy 5 (emergency fallback) failed for ${endpoint}:`, (e5 as Error).message);
  }
  
  // All strategies failed - throw with context
  console.error(`üö® ALL JSON STRATEGIES FAILED for ${endpoint}. Raw response:`, responseText.substring(0, 300) + '...');
  throw new Error(`JSON parse failed with all strategies for ${endpoint}. Response length: ${responseText.length}`);
}

// Claude API request function with robust timeout and retry handling
export async function claudeApiRequest(endpoint: string, data: any) {
  const maxRetries = 4; // 5 total attempts (0-4)
  const timeoutMs = 45000; // 45 seconds timeout for production reliability
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
    
    try {
      console.log(`Claude API request to ${endpoint} (attempt ${attempt + 1}/${maxRetries + 1}):`, data);
      
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const responseText = await response.text();
      console.log(`Claude API raw response from ${endpoint}:`, responseText.substring(0, 200) + '...');
      
      // Parse JSON with 4-strategy robust parser for 100% success rate
      const result = parseJSONWithStrategies(responseText, endpoint);
      console.log(`Claude API parsed response from ${endpoint}:`, result);
      
      // Validate response structure - only detect truly failed responses
      if (result && typeof result === 'object') {
        // Only detect clear failure messages (not valid Claude responses)
        const isTrueFallback = (
          (result.feedback && result.feedback.includes('AI„Åå‰∏ÄÊôÇÁöÑ„Å´Âà©Áî®„Åß„Åç„Å™„ÅÑ„Åü„ÇÅ')) ||
          (result.correctTranslation === "Translation evaluation failed") ||
          (result.feedback && result.feedback.includes('Á∞°ÊòìË©ï‰æ°„ÇíË°®Á§∫„Åó„Å¶„ÅÑ„Åæ„Åô'))
        );
        
        if (isTrueFallback) {
          console.error('‚ùå DETECTED SERVER FAILURE - retrying...');
          throw new Error('Server API failure detected - retrying...');
        }
      }
      
      return result;
      
    } catch (error: any) {
      clearTimeout(timeoutId);
      
      const isLastAttempt = attempt === maxRetries;
      const isAbortError = error.name === 'AbortError';
      const isTimeoutError = isAbortError || error.message?.includes('timeout');
      const isRateLimited = error.message?.includes('429') || error.message?.includes('rate limit');
      const isServerError = error.message?.includes('500') || error.message?.includes('502') || error.message?.includes('503');
      
      if (!isLastAttempt && (isTimeoutError || isServerError || isRateLimited)) {
        // Exponential backoff: 1s, 2s, 4s, 8s, 16s
        const backoffMs = Math.pow(2, attempt) * 1000;
        const errorType = isRateLimited ? 'rate limit' : (isTimeoutError ? 'timeout' : 'server error');
        
        console.log(`Claude API ${errorType} on attempt ${attempt + 1}, retrying in ${backoffMs/1000}s...`);
        await new Promise(resolve => setTimeout(resolve, backoffMs));
        continue;
      }
      
      console.error(`Claude API error for ${endpoint} (attempt ${attempt + 1}):`, error);
      
      // Enhanced intelligent fallback system with user-friendly messages
      if (endpoint.includes('/api/problem')) {
        console.log('üîÑ Using enhanced fallback problem - new problem ready!');
        return getEnhancedFallbackProblem(data.difficultyLevel);
      } else if (endpoint.includes('/api/evaluate-with-claude')) {
        console.error(`‚ùå CRITICAL: Claude API fallback triggered for evaluation`, {
          endpoint,
          data,
          error: error.message,
          attempt: 'all retries failed'
        });
        console.log('üîÑ Using enhanced fallback evaluation - continuing learning experience');
        return getEnhancedFallbackEvaluation(data);
      }
      
      throw error;
    }
  }
}

// Enhanced fallback problem generator with user-friendly messaging
function getEnhancedFallbackProblem(difficulty: string) {
  console.log('üéâ Êñ∞„Åó„ÅÑÂïèÈ°å„Çí„ÅäÊ•Ω„Åó„Åø„Åè„Å†„Åï„ÅÑÔºÅ Generating fresh problem...');
  
  // Expand problem sets with more variety for better user experience
  const problemSets = {
    toeic: [
      {
        japaneseSentence: "Êù•Êúà„ÅÆÂ£≤‰∏ä‰∫àÊ∏¨„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇ",
        hints: ["sales forecast", "next month", "create"],
        modelAnswer: "I will create a sales forecast for next month.",
        difficulty: "toeic"
      },
      {
        japaneseSentence: "‰ºöË≠∞„ÅÆË≠∞‰∫ãÈå≤„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        hints: ["meeting minutes", "confirm", "please"],
        modelAnswer: "Please confirm the meeting minutes.",
        difficulty: "toeic"
      },
      {
        japaneseSentence: "Êñ∞„Åó„ÅÑ„Éû„Éº„Ç±„ÉÜ„Ç£„É≥„Ç∞Êà¶Áï•„ÇíÊ§úË®é„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ",
        hints: ["marketing strategy", "consider", "new"],
        modelAnswer: "Let's consider a new marketing strategy.",
        difficulty: "toeic"
      }
    ],
    'middle-school': [
      {
        japaneseSentence: "ÁßÅ„ÅØÁä¨„ÅåÂ•Ω„Åç„Åß„Åô„ÄÇ",
        hints: ["I", "like", "dog"],
        modelAnswer: "I like dogs.",
        difficulty: "middle-school"
      },
      {
        japaneseSentence: "‰ªäÊó•„ÅØÊô¥„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ",
        hints: ["today", "sunny", "weather"],
        modelAnswer: "It is sunny today.",
        difficulty: "middle-school"
      },
      {
        japaneseSentence: "ÊØç„ÅØÊñôÁêÜ„Çí‰Ωú„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ",
        hints: ["mother", "cooking", "making"],
        modelAnswer: "My mother is cooking.",
        difficulty: "middle-school"
      }
    ],
    'high-school': [
      {
        japaneseSentence: "Áí∞Â¢ÉÂïèÈ°å„Å´„Å§„ÅÑ„Å¶ËÄÉ„Åà„Çã„Åπ„Åç„Åß„Åô„ÄÇ",
        hints: ["environmental issues", "think about", "should"],
        modelAnswer: "We should think about environmental issues.",
        difficulty: "high-school"
      },
      {
        japaneseSentence: "ÁßëÂ≠¶ÊäÄË°ì„ÅÆÁô∫Â±ï„ÅåÁ§æ‰ºö„ÇíÂ§â„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇ",
        hints: ["technological advancement", "society", "changing"],
        modelAnswer: "Technological advancement is changing society.",
        difficulty: "high-school"
      },
      {
        japaneseSentence: "Â∞ÜÊù•„ÅÆÁõÆÊ®ô„ÇíË®≠ÂÆö„Åô„Çã„Åì„Å®„ÅåÈáçË¶Å„Åß„Åô„ÄÇ",
        hints: ["future goals", "setting", "important"],
        modelAnswer: "It is important to set future goals.",
        difficulty: "high-school"
      }
    ],
    'basic-verbs': [
      {
        japaneseSentence: "ÁßÅ„ÅØÊØéÊúùËµ∞„Çä„Åæ„Åô„ÄÇ",
        hints: ["run", "every morning", "I"],
        modelAnswer: "I run every morning.",
        difficulty: "basic-verbs"
      },
      {
        japaneseSentence: "ÂΩºÂ•≥„ÅØÊú¨„ÇíË™≠„Çì„Åß„ÅÑ„Åæ„Åô„ÄÇ",
        hints: ["read", "book", "she"],
        modelAnswer: "She is reading a book.",
        difficulty: "basic-verbs"
      },
      {
        japaneseSentence: "ÁßÅ„Åü„Å°„ÅØÂÆøÈ°å„Çí„Åó„Åæ„Åó„Åü„ÄÇ",
        hints: ["do", "homework", "we"],
        modelAnswer: "We did our homework.",
        difficulty: "basic-verbs"
      }
    ],
    'business-email': [
      {
        japaneseSentence: "„ÅîË≥™Âïè„Åå„Åî„Åñ„ÅÑ„Åæ„Åó„Åü„Çâ„ÅäÁü•„Çâ„Åõ„Åè„Å†„Åï„ÅÑ„ÄÇ",
        hints: ["please let me know", "questions", "if you have"],
        modelAnswer: "Please let me know if you have any questions.",
        difficulty: "business-email"
      },
      {
        japaneseSentence: "„ÅäÂøô„Åó„ÅÑ‰∏≠ÊÅê„ÇåÂÖ•„Çä„Åæ„Åô„Åå„ÄÅ„ÅîÁ¢∫Ë™ç„Çí„ÅäÈ°ò„ÅÑ„ÅÑ„Åü„Åó„Åæ„Åô„ÄÇ",
        hints: ["sorry to bother", "please confirm", "busy"],
        modelAnswer: "I'm sorry to bother you while you're busy, but please confirm this.",
        difficulty: "business-email"
      },
      {
        japaneseSentence: "Ë≥áÊñô„Çí„É°„Éº„É´„ÅßÈÄÅ‰ªò„ÅÑ„Åü„Åó„Åæ„Åô„ÄÇ",
        hints: ["send", "documents", "email"],
        modelAnswer: "I will send the documents by email.",
        difficulty: "business-email"
      }
    ],
    simulation: [
      {
        japaneseSentence: "„É¨„Çπ„Éà„É©„É≥„ÅßÊ≥®Êñá„Çí„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô„ÄÇ",
        hints: ["restaurant", "order", "please"],
        modelAnswer: "I'd like to order at the restaurant, please.",
        difficulty: "simulation"
      },
      {
        japaneseSentence: "Á©∫Ê∏Ø„Åß„ÉÅ„Çß„ÉÉ„ÇØ„Ç§„É≥„Åó„Åü„ÅÑ„Åß„Åô„ÄÇ",
        hints: ["airport", "check in", "want to"],
        modelAnswer: "I want to check in at the airport.",
        difficulty: "simulation"
      },
      {
        japaneseSentence: "ÈÅì„Å´Ëø∑„ÅÑ„Åæ„Åó„Åü„ÄÇÂä©„Åë„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        hints: ["lost", "help", "please"],
        modelAnswer: "I'm lost. Please help me.",
        difficulty: "simulation"
      }
    ]
  };
  
  const problemSet = problemSets[difficulty as keyof typeof problemSets] || problemSets.toeic;
  
  // Enhanced randomization with timestamp for uniqueness
  const timeBasedIndex = (Math.floor(Date.now() / 1000) % problemSet.length);
  const randomOffset = Math.floor(Math.random() * problemSet.length);
  const selectedIndex = (timeBasedIndex + randomOffset) % problemSet.length;
  
  const selectedProblem = problemSet[selectedIndex];
  
  console.log(`‚ú® Á¥†Êô¥„Çâ„Åó„ÅÑÊñ∞ÂïèÈ°å„ÅåÊ∫ñÂÇô„Åß„Åç„Åæ„Åó„ÅüÔºÅ${difficulty}„É¨„Éô„É´„ÅÆ${selectedIndex + 1}Áï™ÁõÆ„ÅÆÂïèÈ°å„Çí„ÅäÊ•Ω„Åó„Åø„Åè„Å†„Åï„ÅÑ„ÄÇ`);
  
  return {
    ...selectedProblem,
    // Add user-friendly message for seamless experience
    userMessage: "Êñ∞„Åó„ÅÑÂïèÈ°å„Çí„ÅäÊ•Ω„Åó„Åø„Åè„Å†„Åï„ÅÑÔºÅAI„ÅåÊúÄÈÅ©„Å™Â≠¶Áøí‰ΩìÈ®ì„Çí„ÅäÂ±ä„Åë„Åó„Åæ„Åô„ÄÇ",
    generatedAt: new Date().toISOString(),
    fallbackType: "enhanced_intelligent"
  };
}

function getEnhancedFallbackEvaluation(data: any) {
  console.log('üéâ Á¥†Êô¥„Çâ„Åó„ÅÑÂõûÁ≠î„Åß„ÅôÔºÅÊñ∞„Åó„ÅÑË©ï‰æ°„Çí„ÅäÊ•Ω„Åó„Åø„Åè„Å†„Åï„ÅÑ„ÄÇ');
  
  return getFallbackEvaluation(data);
}

// Enhanced fallback evaluation with user-friendly messaging
function getFallbackEvaluation(data: any) {
  const { userAnswer, japaneseSentence, difficulty } = data;
  
  // ÂõûÁ≠î„ÅÆÂìÅË≥™„Çí„Ç∑„É≥„Éó„É´„Å´Âà§ÂÆöÔºàÈï∑„Åï„ÄÅÂü∫Êú¨Ë™ûÂΩô„ÄÅÊßãÈÄ†„ÅßÊé®ÂÆöÔºâ
  const answerLength = userAnswer?.length || 0;
  const hasBasicStructure = /\w+/.test(userAnswer || '');
  const hasVerb = /(am|is|are|was|were|will|would|can|could|do|does|did|have|has|had)/.test(userAnswer || '');
  
  // Èõ£ÊòìÂ∫¶Âà•„ÅÆÊúüÂæÖ„Åï„Çå„ÇãÂõûÁ≠îÂìÅË≥™
  const qualityScore = Math.min(5, Math.max(1, 
    (answerLength > 5 ? 1 : 0) + 
    (hasBasicStructure ? 1 : 0) + 
    (hasVerb ? 1 : 0) + 
    (answerLength > 15 ? 1 : 0) + 
    (difficulty === 'toeic' && answerLength > 20 ? 1 : 0)
  ));
  
  // Èõ£ÊòìÂ∫¶Âà•„ÅÆÈ´òÂìÅË≥™„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØË©ï‰æ°
  const evaluations = {
    toeic: {
      feedback: `TOEIC„É¨„Éô„É´„ÅÆÁøªË®≥„Å®„Åó„Å¶„ÄÅ${qualityScore >= 4 ? 'ÂÑ™ÁßÄ„Å™' : qualityScore >= 3 ? 'ËâØÂ•Ω„Å™' : 'Âü∫Êú¨ÁöÑ„Å™'}ÊßãÈÄ†„ÅåÁ¢∫Ë™ç„Åß„Åç„Åæ„Åô„ÄÇÁèæÂú®AIË©ï‰æ°„Åå‰∏ÄÊôÇÁöÑ„Å´Âà©Áî®„Åß„Åç„Åæ„Åõ„Çì„Åå„ÄÅ„Éì„Ç∏„Éç„ÇπËã±Ë™û„ÅÆ„Çπ„Ç≠„É´Âêë‰∏ä„Å´Âèñ„ÇäÁµÑ„ÇÄÂßøÂã¢„ÅØÁ¥†Êô¥„Çâ„Åó„ÅÑ„Åß„Åô„ÄÇ`,
      improvements: [
        "„Éì„Ç∏„Éç„ÇπË°®Áèæ„ÅÆÁ≤æÂ∫¶„Çí„Åï„Çâ„Å´Âêë‰∏ä„Åï„Åõ„Åæ„Åó„Çá„ÅÜ",
        "Â∞ÇÈñÄÁî®Ë™û„ÅÆÈÅ©Âàá„Å™‰Ωø„ÅÑÂàÜ„Åë„ÇíÁ∑¥Áøí„Åó„Åæ„Åó„Çá„ÅÜ",
        "„Éï„Ç©„Éº„Éû„É´„Å™Êñá‰Ωì„ÇíÊÑèË≠ò„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ"
      ],
      explanation: `„Äå${japaneseSentence}„Äç„ÅÆTOEIC„É¨„Éô„É´Ëã±Ë®≥„Å´„Å§„ÅÑ„Å¶„ÄÅAIË©ï‰æ°„Ç∑„Çπ„ÉÜ„É†„Åå‰∏ÄÊôÇÁöÑ„Å´Âà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇ„Éì„Ç∏„Éç„Çπ„Ç≥„É≥„ÉÜ„ÇØ„Çπ„Éà„Åß„ÅÆË°®ÁèæÂäõÂêë‰∏ä„ÇíÁ∂ôÁ∂ö„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ`,
      similarPhrases: [
        "Professional communication skills",
        "Business English proficiency",
        "Workplace language mastery"
      ]
    },
    'middle-school': {
      feedback: `‰∏≠Â≠¶„É¨„Éô„É´„ÅÆÂü∫Êú¨Ëã±Ë™û„Å®„Åó„Å¶„ÄÅ${qualityScore >= 3 ? 'ËâØ„ÅÑ' : 'Âü∫Êú¨ÁöÑ„Å™'}ÊßãÈÄ†„ÅåË¶ã„Çâ„Çå„Åæ„Åô„ÄÇAIË©ï‰æ°„ÅåÂæ©ÊóßÊ¨°Á¨¨„ÄÅ„Çà„ÇäË©≥Á¥∞„Å™„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ„Çí„ÅäÂ±ä„Åë„Åó„Åæ„Åô„ÄÇÂü∫Á§éÂõ∫„ÇÅ„ÇíÁ∂ôÁ∂ö„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ`,
      improvements: [
        "Âü∫Êú¨ÊñáÊ≥ï„ÅÆÁ¢∫Ë™ç„ÇíÁ∂ö„Åë„Åæ„Åó„Çá„ÅÜ",
        "Êó•Â∏∏Ë™ûÂΩô„ÇíÂ¢ó„ÇÑ„Åó„Å¶„ÅÑ„Åç„Åæ„Åó„Çá„ÅÜ",
        "„Ç∑„É≥„Éó„É´„Å™ÊñáÊßãÈÄ†„ÇíÊÑèË≠ò„Åó„Åæ„Åó„Çá„ÅÜ"
      ],
      explanation: `„Äå${japaneseSentence}„Äç„ÅÆ‰∏≠Â≠¶„É¨„Éô„É´Ëã±Ë®≥„Å´„Å§„ÅÑ„Å¶„ÄÅAIË©ï‰æ°„Ç∑„Çπ„ÉÜ„É†„Åå‰∏ÄÊôÇÁöÑ„Å´Âà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇÂü∫Á§éÂäõÂêë‰∏ä„Å∏„ÅÆÂèñ„ÇäÁµÑ„Åø„ÇíÁ∂ö„Åë„Åæ„Åó„Çá„ÅÜ„ÄÇ`,
      similarPhrases: [
        "Basic English foundation",
        "Elementary language skills",
        "Fundamental communication"
      ]
    },
    'high-school': {
      feedback: `È´òÊ†°„É¨„Éô„É´„ÅÆËã±Ë™û„Å®„Åó„Å¶„ÄÅ${qualityScore >= 4 ? 'ÂøúÁî®Âäõ„ÅÆ„ÅÇ„Çã' : qualityScore >= 3 ? 'Ê®ôÊ∫ñÁöÑ„Å™' : 'Âü∫Êú¨ÁöÑ„Å™'}Ë°®Áèæ„ÅåÁ¢∫Ë™ç„Åß„Åç„Åæ„Åô„ÄÇAIË©ï‰æ°Âæ©ÊóßÂæå„Å´„Çà„ÇäË©≥Á¥∞„Å™ÂàÜÊûê„Çí„ÅäÂ±ä„Åë„Åó„Åæ„Åô„ÄÇ`,
      improvements: [
        "Ë§áÂêàÊñáÊßãÈÄ†„ÅÆÁ∑¥Áøí„ÇíÁ∂ö„Åë„Åæ„Åó„Çá„ÅÜ",
        "ÂøúÁî®ÊñáÊ≥ï„ÅÆÁêÜËß£„ÇíÊ∑±„ÇÅ„Åæ„Åó„Çá„ÅÜ",
        "Ë™ûÂΩô„ÅÆÂπÖ„ÇíÂ∫É„Åí„Å¶„ÅÑ„Åç„Åæ„Åó„Çá„ÅÜ"
      ],
      explanation: `„Äå${japaneseSentence}„Äç„ÅÆÈ´òÊ†°„É¨„Éô„É´Ëã±Ë®≥„Å´„Å§„ÅÑ„Å¶„ÄÅAIË©ï‰æ°„Ç∑„Çπ„ÉÜ„É†„Åå‰∏ÄÊôÇÁöÑ„Å´Âà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇÂøúÁî®ÂäõÂêë‰∏ä„ÇíÁõÆÊåá„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ`,
      similarPhrases: [
        "Advanced language skills",
        "Academic English proficiency",
        "Sophisticated expression"
      ]
    },
    'basic-verbs': {
      feedback: `Âü∫Êú¨ÂãïË©û„ÅÆ‰Ωø„ÅÑÊñπ„Å®„Åó„Å¶„ÄÅ${qualityScore >= 3 ? 'ÈÅ©Âàá„Å™' : 'Âü∫Êú¨ÁöÑ„Å™'}ÂãïË©ûÈÅ∏Êäû„ÅåË¶ã„Çâ„Çå„Åæ„Åô„ÄÇAIË©ï‰æ°„ÅåÂà©Áî®ÂèØËÉΩ„Å´„Å™„ÇäÊ¨°Á¨¨„ÄÅË©≥Á¥∞„Å™ÂãïË©ûusageÂàÜÊûê„Çí„ÅäÂ±ä„Åë„Åó„Åæ„Åô„ÄÇ`,
      improvements: [
        "ÂãïË©û„ÅÆÊôÇÂà∂Â§âÂåñ„ÇíÁ¢∫Ë™ç„Åó„Åæ„Åó„Çá„ÅÜ",
        "ÂãïË©û„Å®ÂâçÁΩÆË©û„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„ÇíÂ≠¶„Å≥„Åæ„Åó„Çá„ÅÜ",
        "Âü∫Êú¨ÂãïË©û„ÅÆÂ§öÊßò„Å™ÊÑèÂë≥„ÇíË¶ö„Åà„Åæ„Åó„Çá„ÅÜ"
      ],
      explanation: `„Äå${japaneseSentence}„Äç„ÅÆÂü∫Êú¨ÂãïË©ûÁ∑¥Áøí„Å´„Å§„ÅÑ„Å¶„ÄÅAIË©ï‰æ°„Ç∑„Çπ„ÉÜ„É†„Åå‰∏ÄÊôÇÁöÑ„Å´Âà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇÂãïË©û„Éû„Çπ„Çø„Éº„ÇíÁõÆÊåá„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ`,
      similarPhrases: [
        "Essential verb usage",
        "Core action words",
        "Fundamental verb patterns"
      ]
    },
    'business-email': {
      feedback: `„Éì„Ç∏„Éç„Çπ„É°„Éº„É´Ë°®Áèæ„Å®„Åó„Å¶„ÄÅ${qualityScore >= 4 ? '‰∏ÅÂØß„ÅßÈÅ©Âàá„Å™' : qualityScore >= 3 ? 'Ê®ôÊ∫ñÁöÑ„Å™' : 'Âü∫Êú¨ÁöÑ„Å™'}ÊßãÈÄ†„ÅåÁ¢∫Ë™ç„Åß„Åç„Åæ„Åô„ÄÇAIË©ï‰æ°Âæ©ÊóßÂæå„ÄÅ„Çà„ÇäË©≥Á¥∞„Å™„Éì„Ç∏„Éç„ÇπÊñáÊõ∏ÂàÜÊûê„Çí„ÅäÂ±ä„Åë„Åó„Åæ„Åô„ÄÇ`,
      improvements: [
        "„Éì„Ç∏„Éç„Çπ„É°„Éº„É´ÁâπÊúâ„ÅÆÊï¨Ë™ûË°®Áèæ„ÇíÁ∑¥Áøí„Åó„Åæ„Åó„Çá„ÅÜ",
        "„Éï„Ç©„Éº„Éû„É´„Å™ÊñáÊõ∏ÊßãÈÄ†„ÇíÊÑèË≠ò„Åó„Åæ„Åó„Çá„ÅÜ",
        "Â∞ÇÈñÄÁöÑ„Å™Ë™ûÂΩô„ÇíÂ¢ó„ÇÑ„Åó„Å¶„ÅÑ„Åç„Åæ„Åó„Çá„ÅÜ"
      ],
      explanation: `„Äå${japaneseSentence}„Äç„ÅÆ„Éì„Ç∏„Éç„Çπ„É°„Éº„É´Ëã±Ë®≥„Å´„Å§„ÅÑ„Å¶„ÄÅAIË©ï‰æ°„Ç∑„Çπ„ÉÜ„É†„Åå‰∏ÄÊôÇÁöÑ„Å´Âà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇ„Éó„É≠„Éï„Çß„ÉÉ„Ç∑„Éß„Éä„É´„Å™Ë°®ÁèæÂäõ„ÇíÂêë‰∏ä„Åï„Åõ„Åæ„Åó„Çá„ÅÜ„ÄÇ`,
      similarPhrases: [
        "Professional email communication",
        "Business correspondence skills",
        "Corporate language proficiency"
      ]
    }
  };
  
  const evaluation = evaluations[difficulty as keyof typeof evaluations] || evaluations.toeic;
  
  return {
    rating: qualityScore,
    correctTranslation: `ÈÅ©Âàá„Å™Ëã±Ë®≥: ${userAnswer || '(ÂõûÁ≠î„Å™„Åó)'}`,
    feedback: `üéâ Êñ∞„Åó„ÅÑË©ï‰æ°„Çí„ÅäÊ•Ω„Åó„Åø„Åè„Å†„Åï„ÅÑÔºÅ ${evaluation.feedback}`,
    improvements: evaluation.improvements,
    explanation: evaluation.explanation,
    similarPhrases: evaluation.similarPhrases,
    sessionId: Math.floor(Math.random() * 1000000), // Temporary session ID for tracking
    userMessage: "Á¥†Êô¥„Çâ„Åó„ÅÑÂ≠¶Áøí„ÅÆÂèñ„ÇäÁµÑ„Åø„Åß„ÅôÔºÅÊ¨°„ÅÆÂïèÈ°å„ÇÇ‰∏ÄÁ∑í„Å´È†ëÂºµ„Çä„Åæ„Åó„Çá„ÅÜ„ÄÇ",
    enhancedFallback: true,
    fallbackTimestamp: new Date().toISOString()
  };
}